import{s as y,r as D,n as M}from"../chunks/scheduler.B-KQ0TV-.js";import{S as q,i as V,m as _,n as g,o as E,k as v,l as S,p as w,s as N,f as I,g as f,d as c,e as d,c as $,a as b,r as m,h as L,u as T,v as P,w as x,t as G,b as H,j as k}from"../chunks/index.BVfQ5-ZG.js";import{E as U,a as O,b as A}from"../chunks/EtudeCard.B43HAU2N.js";class R extends Error{constructor(e){super(e),this.name="PartitionError"}}class j extends R{constructor(e){super(`Line contains mixed or invalid delimiters: ${e}`),this.name="DelimiterError"}}class F extends R{constructor(e){super(`Invalid comment format: ${e}`),this.name="CommentError"}}class W extends R{constructor(e){super(`Invalid separator format: ${e}`),this.name="SeparatorError"}}const C={SEPARATOR_STRING:"--------",INVALID_SCENARIO_MESSAGE:"# INVALID SCENARIO",COMMON_ERROR_MESSAGE:"# INVALID: %s",INVALID_LINE_ERROR_HELP:"#   REASON: Line contains unrecognised symbols"};function z(n){return/^[\d,\s]+$/.test(n.trim())}function B(n){return n.trim().startsWith("#")}function X(n){return n.trim()===""}function J(n){return/^-+$/.test(n.trim())}function K(n){const e=n.trim();if(e.includes(",")&&e.includes(" "))throw new j(n);const i=e.split(/[,\s]+/).map(Number);if(i.some(isNaN))throw new R(`Invalid numbers in partition: ${n}`);for(let t=1;t<i.length;t++)if(i[t]>i[t-1])throw new R(`Numbers must be in descending order: ${n}`);return{value:i.join(" "),lineType:3}}function Q(n){const e=n.trim();if(!e.startsWith("#"))throw new F(n);return{value:e,lineType:1}}function Y(n){if(n.trim().length<3)throw new W(n);return{value:C.SEPARATOR_STRING,lineType:2}}function Z(n){if(X(n))return{value:"",lineType:0};if(B(n))return Q(n);if(J(n))return Y(n);if(z(n))return K(n);throw new R(`Invalid line format: ${n}`)}function ee(n){const e=n.split(`
`),i=[];let t={lines:[],valid:!1},s=!0,l=0;for(const r of e)try{const a=Z(r);if(a.lineType!==0&&a.lineType!==2&&(s=!1),a.lineType===3&&(t.valid=!0),a.lineType===0){if(l>0)continue;l++}else l=0;if(a.lineType===2){t.lines.length>0&&!s&&i.push(t),t={lines:[],valid:!1},s=!0;continue}a.value&&t.lines.push(a.value)}catch(a){a instanceof R&&(t.lines.push(C.COMMON_ERROR_MESSAGE.replace("%s",r),C.INVALID_LINE_ERROR_HELP),s=!1)}return t.lines.length>0&&!s&&i.push(t),i}function te(n){let e,i=`Enter partition data using either spaces or commas as delimiters. Numbers must be in
					descending order. Use "---" to separate scenarios.`,t,s,l,r,a="Parse Partitions",o,p;return{c(){e=d("p"),e.textContent=i,t=N(),s=d("textarea"),l=N(),r=d("button"),r.textContent=a,this.h()},l(u){e=$(u,"P",{class:!0,"data-svelte-h":!0}),T(e)!=="svelte-go8fo0"&&(e.textContent=i),t=I(u),s=$(u,"TEXTAREA",{class:!0,placeholder:!0,rows:!0,spellcheck:!0}),b(s).forEach(c),l=I(u),r=$(u,"BUTTON",{class:!0,"data-svelte-h":!0}),T(r)!=="svelte-1owyif9"&&(r.textContent=a),this.h()},h(){m(e,"class","etude-info svelte-9wrr81"),m(s,"class","etude-input svelte-9wrr81"),m(s,"placeholder","Enter partitions..."),m(s,"rows","10"),m(s,"spellcheck","false"),m(r,"class","etude-button svelte-9wrr81")},m(u,h){f(u,e,h),f(u,t,h),f(u,s,h),P(s,n[0]),f(u,l,h),f(u,r,h),o||(p=[x(s,"input",n[3]),x(r,"click",n[2])],o=!0)},p(u,h){h&1&&P(s,u[0])},d(u){u&&(c(e),c(t),c(s),c(l),c(r)),o=!1,D(p)}}}function se(n){let e,i;return{c(){e=d("pre"),i=G(n[1]),this.h()},l(t){e=$(t,"PRE",{class:!0});var s=b(e);i=H(s,n[1]),s.forEach(c),this.h()},h(){m(e,"class","etude-pre")},m(t,s){f(t,e,s),L(e,i)},p(t,s){s&2&&k(i,t[1])},d(t){t&&c(e)}}}function re(n){let e,i,t,s,l;return i=new A({props:{title:"Input",$$slots:{default:[te]},$$scope:{ctx:n}}}),s=new A({props:{title:"Output",$$slots:{default:[se]},$$scope:{ctx:n}}}),{c(){e=d("div"),_(i.$$.fragment),t=N(),_(s.$$.fragment),this.h()},l(r){e=$(r,"DIV",{class:!0});var a=b(e);g(i.$$.fragment,a),t=I(a),g(s.$$.fragment,a),a.forEach(c),this.h()},h(){m(e,"class","etude-grid")},m(r,a){f(r,e,a),E(i,e,null),L(e,t),E(s,e,null),l=!0},p(r,a){const o={};a&17&&(o.$$scope={dirty:a,ctx:r}),i.$set(o);const p={};a&18&&(p.$$scope={dirty:a,ctx:r}),s.$set(p)},i(r){l||(v(i.$$.fragment,r),v(s.$$.fragment,r),l=!0)},o(r){S(i.$$.fragment,r),S(s.$$.fragment,r),l=!1},d(r){r&&c(e),w(i),w(s)}}}function ne(n){let e,i=`3 2 1
5,4,3
---
2 2
1 1 1 1`,t,s,l="<li>Space-separated numbers: &quot;3 2 1&quot;</li> <li>Comma-separated numbers: &quot;3,2,1&quot;</li> <li>Single numbers: &quot;5&quot;</li> <li>Comments starting with #</li> <li>Scenario separators: &quot;---&quot; or more dashes</li>";return{c(){e=d("pre"),e.textContent=i,t=N(),s=d("ul"),s.innerHTML=l,this.h()},l(r){e=$(r,"PRE",{class:!0,"data-svelte-h":!0}),T(e)!=="svelte-19tr4wp"&&(e.textContent=i),t=I(r),s=$(r,"UL",{class:!0,"data-svelte-h":!0}),T(s)!=="svelte-1s88c3h"&&(s.innerHTML=l),this.h()},h(){m(e,"class","etude-pre"),m(s,"class","etude-list")},m(r,a){f(r,e,a),f(r,t,a),f(r,s,a)},p:M,d(r){r&&(c(e),c(t),c(s))}}}function ie(n){let e,i="<li>Numbers must be valid integers</li> <li>Numbers must be in descending order</li> <li>No mixing of delimiters (spaces and commas)</li> <li>Comments must start at beginning of line</li> <li>Separators must have at least 3 dashes</li> <li>Empty lines are compressed</li>";return{c(){e=d("ul"),e.innerHTML=i,this.h()},l(t){e=$(t,"UL",{class:!0,"data-svelte-h":!0}),T(e)!=="svelte-3zttl5"&&(e.innerHTML=i),this.h()},h(){m(e,"class","etude-list")},m(t,s){f(t,e,s)},p:M,d(t){t&&c(e)}}}function ae(n){let e,i,t,s,l;return i=new A({props:{title:"Valid Formats",$$slots:{default:[ne]},$$scope:{ctx:n}}}),s=new A({props:{title:"Validation Rules",$$slots:{default:[ie]},$$scope:{ctx:n}}}),{c(){e=d("div"),_(i.$$.fragment),t=N(),_(s.$$.fragment),this.h()},l(r){e=$(r,"DIV",{class:!0});var a=b(e);g(i.$$.fragment,a),t=I(a),g(s.$$.fragment,a),a.forEach(c),this.h()},h(){m(e,"class","etude-grid")},m(r,a){f(r,e,a),E(i,e,null),L(e,t),E(s,e,null),l=!0},p(r,a){const o={};a&16&&(o.$$scope={dirty:a,ctx:r}),i.$set(o);const p={};a&16&&(p.$$scope={dirty:a,ctx:r}),s.$set(p)},i(r){l||(v(i.$$.fragment,r),v(s.$$.fragment,r),l=!0)},o(r){S(i.$$.fragment,r),S(s.$$.fragment,r),l=!1},d(r){r&&c(e),w(i),w(s)}}}function le(n){let e,i,t,s;return e=new O({props:{title:"Partition Parser",$$slots:{default:[re]},$$scope:{ctx:n}}}),t=new O({props:{title:"Format Guide",$$slots:{default:[ae]},$$scope:{ctx:n}}}),{c(){_(e.$$.fragment),i=N(),_(t.$$.fragment)},l(l){g(e.$$.fragment,l),i=I(l),g(t.$$.fragment,l)},m(l,r){E(e,l,r),f(l,i,r),E(t,l,r),s=!0},p(l,r){const a={};r&19&&(a.$$scope={dirty:r,ctx:l}),e.$set(a);const o={};r&16&&(o.$$scope={dirty:r,ctx:l}),t.$set(o)},i(l){s||(v(e.$$.fragment,l),v(t.$$.fragment,l),s=!0)},o(l){S(e.$$.fragment,l),S(t.$$.fragment,l),s=!1},d(l){l&&c(i),w(e,l),w(t,l)}}}function oe(n){let e,i;return e=new U({props:{title:"Parsing Partitions",description:"Parse and validate integer partition data with support for various formats and comprehensive error handling.",$$slots:{default:[le]},$$scope:{ctx:n}}}),{c(){_(e.$$.fragment)},l(t){g(e.$$.fragment,t)},m(t,s){E(e,t,s),i=!0},p(t,[s]){const l={};s&19&&(l.$$scope={dirty:s,ctx:t}),e.$set(l)},i(t){i||(v(e.$$.fragment,t),i=!0)},o(t){S(e.$$.fragment,t),i=!1},d(t){w(e,t)}}}function ue(n,e,i){let t=`1 1 1
3
---
2 2
1 1 1 1`,s="";function l(){try{const a=ee(t),o=[];a.forEach((p,u)=>{p.valid||o.push(C.INVALID_SCENARIO_MESSAGE),o.push(...p.lines),u<a.length-1&&o.push(C.SEPARATOR_STRING)}),i(1,s=o.join(`
`))}catch(a){i(1,s=`Error processing input: ${a.message}`)}}function r(){t=this.value,i(0,t)}return[t,s,l,r]}class pe extends q{constructor(e){super(),V(this,e,ue,oe,y,{})}}export{pe as component};
